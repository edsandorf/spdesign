---
title: "spdesignR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{spdesignR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(spdesignR)
```

# Introduction


# Syntax

## Estimation options
The package comes with a large number of estimation options. For more complex designs such as mixed logit designs with many draws, we recommend using multiple cores for faster evaluation of the designs. 


```{r}
estim_opts <- list(
  cores = 1,
  silent = FALSE,
  max_eval = NA,
  max_time = NA
)
```

## Specifying design options
The package allows for flexible designs. General design options are collected in the list `design_opts'. 

```{r, eval = FALSE}
design_opts <- list(
  S = 12,
  R = NA,
  model = "mnl",
  eff_crit = "d",
  blocks = 1
)
```

The utility functions are specified as a list, where each list element is a character string defining the functional form of utility. The parameter and its prior value, and an attribute and its levels are separated by the pipe parameter. Multiple parameter values or distributions for parameter values are put in a concatenated vector. The values that an attribute can take are given as concatenated vector (as is common in R). If this vector is a character string of levels, then it will be convered to an integer sequence when creating the design.

For example, if you have two unlabeled alternatives, "alt_1" and "alt_2", you can specify the list of utility functions as follows:


```{r, eval = FALSE}
utility_funcs <- list(
  alt_1 = "beta_1 | 0.1 * x_1 | c(0, 1) + beta_2 | -0.1 * x_2 | c(2, 4, 6, 8)",
  alt_2 = "beta_1 * x_1 + beta_2 * x_2"
)
```

It is important when specifying the utility functions that the parameter preceeds the attribute. The function that parses the utility expressions assumes that the parameter is to the left of the asterisk and the attribute to the right. Different attributes, or interaction terms, are separated by the addition symbol. 

You can specify an attribute to be a dummy using the _dummy notation. Notice that we have specified two prior values for the parameters in a concatenated vector, but that the attribute can take on three levels. This is because the last level used to normalize and we only have dummies for the first and second level.

```{r, eval = FALSE}
utility_funcs <- list(
  alt_1 = "beta_1 | c(0.1, 0.1) * x_1_dummy | c(0, 1, 2) + beta_2 | -0.1 * x_2 | c(2, 4, 6, 8)",
  alt_2 = "beta_1 * x_1 + beta_2 * x_2"
)
```

If a parameter follows a distribution 

```{r, eval = FALSE}
utility_funcs <- list(
  alt_1 = "beta_1 | N[0, 1] * x_1 | c(0, 1) + beta_2 | -0.1 * x_2 | c(2, 4, 6, 8)",
  alt_2 = "beta_1 * x_1 + beta_2 * x_2"
)
```

We can use the _dummy notation even when we use a Bayesian design.

```{r, eval = FALSE}
utility_funcs <- list(
  alt_1 = "beta_1 | c(N[0, 1], N[0, 1]) * x_1 | c(0, 1, 2) + beta_2 | -0.1 * x_2 | c(2, 4, 6, 8)",
  alt_2 = "beta_1 * x_1 + beta_2 * x_2"
)
```

### Specifying the utility functions



### Specifying restrictions
